<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF8">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Метод Хука - Дживса</title>
</head>

<body BGCOLOR="lightyellow">

<h1>Метод Хука - Дживса</h1>
<br>
<h2>Общие сведения о методе</h2>
Процедура Хука и Дживса представляет собой комбинацию двух типов поиска: исследующий поиск и поиск по образцу.
<br><b>Исследующий поиск</b> ориентирован на выявление характера локального поведения целевой функции и определение направлений вдоль "оврагов". 
<br>Для проведения <b>исследующего поиска</b> необходимо задать величину шага,
<br>которая может быть различной для разных координатных направлений и изменяться в процессе поиска.
<br><b>Исследующий поиск</b> начинается в некоторой исходной точке. Если значение целевой функции в пробной
<br>точке  не превышает  значения функции в исходной точке, то шаг поиска рассматривается как успешный.
<br>В противном случае необходимо вернуться в предыдущую точку и сделать шаг в противоположном направлении
<br>с последующей проверкой значения целевой функции. После перебора всех  координатных направлений
<br>исследующий поиск завершается. Полученную в результате точку называют <b>базисной точкой</b>.
<br>
<br><b>Поиск по образцу</b> заключается в реализации единственного шага из полученной <b>базисной точки</b> вдоль прямой,
<br>соединяющей эту точку с предыдущей <b>базисной точкой</b>. Новая точка образца определяется в соответствии с формулой.
<br><center>P = oldB + 2(newB - oldB) </center>
<br>Движение по образцу считается успешным, если <b>исследующий поиск</b>, проведенный  из точки P, приводит к
<br>уменьшению целевой функции. В этом случае полученная точка рассматривается как новая <b>базисная точка</b>.
<br>Если <b>исследующий поиск</b>, проведенный после поиска по образцу, неудачен,  то необходимо вернуться в точку newB
<br>и провести исследующий поиск с целью выявления нового направления минимизации.
<br>В конечном счете возникает ситуация, когда такой поиск не приводит к успеху. В этом случае требуется
<br>уменьшить величину шага при исследующем поиске (например в 10 раз) и возобновить <b>исследующий поиск</b>.
<br>Поиск завершается, когда величина исследующего шага становится достаточно малой.
<br><br>
<h2>Алгоритм</h2>
<h3>Аргументы алгоритма</h3>
H1 - шаг по оси X1 <br>
H2 - шаг по оси X2 <br>
F(X1; X2) - целевая функция <br>
E - точность вычислений <br>
oldB - начальная точка или старая базисная точка <br>
newB - новая базисная точка <br>
<h3>Последовательность шагов</h3>
<ul type="circle">
<li>Шаг1</li>
Выполняем <b>исследующий поиск</b> из начальной точки oldB (базисной точки) c целью нахождения точки newB (новой базисной точки):
	<br> 1) Изменяем X1 в положительную сторону на значение H1. <br>
	Если значение F(X1 + H1; X2) < F(X1; X2), то необходимо принять новую точку newB и перейти к пункту 3. Иначе - переходим к пункту 2.
	<br> 2) Изменяем X1 в отрицательную сторону на значение H1. <br>
	Если значение F(X1 - H1; X2) < F(X1; X2), то необходимо принять новую точку newB. Переходим к пункту 3.
	<br> 3) Изменяем X2 в положительную сторону на значение H2. <br>
	Если значение F(X1; X2 + H2) < F (X1; X2), то необходимо принять новую точку newB и перейти к шагу 2. Иначе - переходим к пунтку 4.
	<br> 4) Изменяем X2 в отрицательную сторону на значение H2. <br>
	Если значение F(X1; X2 - H2) < F (X1; X2), то необходимо принять новую точку newB. Переходим к шагу 2.
<li>Шаг2</li>
Если не было принято ни одной новой точки newB, то необходимо уменьшить шаг:
<br> Если уменьшили шаг и длина шага max(H1, H2) < E, то завершаем процесс минимизации. Иначе переходим к шагу 1.
<br> Если шаг не уменьшали, то переходим к шагу 3.
<li>Шаг3</li>
Выполняем <b>поиск по образцу</b>, вычисляя промежуточную точку P = oldB + 2(newB - oldB) и значение функции в этой точке. Переходим к шагу 4.
<li>Шаг4</li>
Выполняем <b>исследующий поиск</b> из промежуточной точки:
	<br> 1) Изменяем X1 в положительную сторону на значение H1. <br>
	Если значение F(X1 + H1; X2) < F(X1; X2), то необходимо принять новую точку P1 и перейти к пункту 3. Иначе - переходим к пункту 2.
	<br> 2) Изменяем X1 в отрицательную сторону на значение H1. <br>
	Если значение F(X1 - H1; X2) < F(X1; X2), то необходимо принять новую точку P1. Переходим к пункту 3.
	<br> 3) Изменяем X2 в положительную сторону на значение H2. <br>
	Если значение F(X1; X2 + H2) < F (X1; X2), то необходимо принять новую точку P1 и перейти к шагу 5. Иначе - переходим к пунтку 4.
	<br> 4) Изменяем X2 в отрицательную сторону на значение H2. <br>
	Если значение F(X1; X2 - H2) < F (X1; X2), то необходимо принять новую точку P1. Переходим к шагу 5.
<li>Шаг5</li>
Если F(P1) < F(newB), то поиск по образцу принять успешным и точку P1 назначить новой базисной точкой newB, а newB старой базисной точкой oldB и перейти к шагу 3.
<br>Иначе переходим к шагу 1 приняв oldB начальной базисной точкой.
</ul>
<h2>Блок - схема алгоритма</h2>
<p><img src="BlockSchem4.JPG" alt="Блок-схема"></p>
</body>