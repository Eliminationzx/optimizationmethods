Прежде чем описать структуру классов программы необходимо указать особенности библиотеки Qt. Основная особенность это механизм сигналов и слотов. Любой наследник QObject может иметь сигналы и слоты.
class MyClass :  public QObject{
Q_OBJECT
public slots:
	void MySlot(int n);
signals:
	void MySignal(int n);
}
 Слот это обычная функция с одной особенностью её можно соединить с сигналом. Сигнал синтаксически похож на функцию. Строка emit MySignal(235); равносильна вызову слота связанного с этим сигналом, с сигналом можно связать произвольное число слотов и можно изменять эти связи во время выполнения программы. Большинство классов Qt имеют слоты и высылают сигналы при изменении полей или других событиях.

Функции
Обозначено оранжевым цветом
Чтобы обеспечить работу с двумя типами функций применён паттерн стратегия. Класс funkcio обеспечивает общий интерфейс: возможность задания параметров функции и возврат её значения в точке. KvadratigantoFunkcio и RavinaFunkcio реализуют конкретные типы функций. Интерфейс funkcio избыточен, т.к. надо поддержать оба типа. Неиспользуемые параметры просто игнорируются.

Точка
Обозначено зелёным цветом
Стандартный класс двумерной точки — QPointF не высылает сигналы при своём изменении. Мы реализовали такую возможность. В результате можно связать объект точки и текстовые поля на форме при создании окна, и в остальном коде не заботится о выводе координат в текстовые поля.
Для наследников QObject нельзя создавать конструктор копирования. Поэтому был создан класс DemonstrataQPointF полностью совместимый с QPointF и вызывающий SignalantoPorPointF::SendiSignaloj() при каждом своём изменении. SignalantoPorPointF высылает сигналы с новыми значениями координат. Каждому объекту DemonstrataQPointF должен соответствовать один объект SignalantoPorPointF.

Окно выбора варианта.
Обозначено розовым цветом
MainWindowImpl — класс окна выбора алгоритма, варианта и типа функции. После выбора запускается один из наследников AlgoritmoWin.

Окна прохождения алгоритмов
Обозначено жёлтым цветом
Для обеспечения работы с разными алгоритмами был использован паттерн стратегия. Абстрактный класс AlgoritmoWin обеспечивает общее для всех поведение и базовый интерфейс: запуск из MainWindowImpl с заданными функцией, начальной точкой, числом возможных ошибок. В наследниках AlgoritmoWin реализованы алгоритмы: CWdescentWinImpl — покоординатный спуск с фиксированным шагом, CWdescent_mdImpl — покоординатный спуск с минимизацией по направлению, FasterDescentImpl — наискорейший спуск, HuGiImpl — метод Хука-Дживса, NeMiImpl — метод Нелдора-Мида, NotWenImpl — метод Ньютона. Описания алгоритмов см. в .
Для пошагового прохождения алгоритмов был использован паттерн конечный автомат. Библиотека Qt имеет каркас для поддержки этого паттерна (см. http://doc.crossplatform.ru/qt/4.6.x/statemachine-api.html). Диаграммы состояний для алгоритмов см. в приложении 4.

Карта высот функции
Обозначено жёлтым цветом
Для карты высот был создан собственный виджет — ScenoPorMapo. При создании ему передаётся функция, карту высот которой надо построить.

След прохождения
Обозначено белым цветом.
Для разных алгоритмов надо рисовать разные следы на карте. Это реализовано с помощью паттерна состояние. В конструкторе окна метода создаётся соответствующий объект следа. По средствам сигналов и слотов связывается с точками. И указатель на него передаётся в виджет карты.